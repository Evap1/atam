.global _start

.section .text
_start:
    movw $3, type            # Initialize type to 3
    movq size, %r9           # Load size into r9
    movq data, %r10          # Load address of data into r10
    movq size, %r13          # Load size into r13
    shrq $3, %r13            # Divide size by 8 (size/8)
    andq $7, %r9             # r9 = r9 & 7 (check if size is divisible by 8)
    testq %r9, %r9           # Update ZF based on r9
    je loop_zeros            # Jump if size is divisible by 8

loop_zeros:
    movq $0, %r11
    movq (%r10, %r11, 8), %r12 # Iterates data using base=data and iterator=R11
    testq %r12, %r12         # Check if quad value is 0
    je update_type4
    addq $1, %r11            # I++
    cmpq %r11, %r13          # r11 - r13
    jb loop_zeros            # index < size

    cmpw $3, type            # Compare type with 3
    je end                   # Exit if type is 3

    movw $1, type            # Initialize type to 1 for simple set check

loop_simple:
    movq $0, %r11            # Reset index to 0

check_simple_char:
    movb (%r10, %r11), %al   # Load byte from data
    cmpb $0, %al             # Check if null terminator
    je end_simple_check

    # Check if character is a letter (A-Z or a-z)
    cmpb $'A', %al
    jb not_simple
    cmpb $'Z', %al
    jbe simple_char
    cmpb $'a', %al
    jb not_simple
    cmpb $'z', %al
    jbe simple_char

    # Check if character is a digit (0-9)
    cmpb $'0', %al
    jb not_simple
    cmpb $'9', %al
    jbe simple_char

    # Check if character is punctuation (',', '.', '?', '!', ' ')
    cmpb $33, %al    # ASCII value of '!' is 33
    je simple_char
    cmpb $63, %al    # ASCII value of '?' is 63
    je simple_char
    cmpb $46, %al    # ASCII value of '.' is 46
    je simple_char
    cmpb $44, %al    # ASCII value of ',' is 44
    je simple_char
    cmpb $32, %al    # ASCII value of space ' ' is 32
    je simple_char

not_simple:
    movw $2, type            # Set type to 2
    jmp end_simple_check     # Jump to end check

simple_char:
    incq %r11                # Increment index
    cmpq %r11, %r9           # Compare index with size
    jb check_simple_char     # Loop if index < size

end_simple_check:
    cmpw $1, type            # Check if type is 1
    je end                   # Exit if type is 1

loop_science:
    movq $0, %r11            # Reset index to 0

check_science_char:
    movb (%r10, %r11), %al   # Load byte from data
    cmpb $0, %al             # Check if null terminator
    je end_science_check
    cmpb $32, %al
    jb not_science           # Check if character < 32
    cmpb $126, %al
    ja not_science           # Check if character > 126

    incq %r11                # Increment index
    cmpq %r11, %r9           # Compare index with size
    jb check_science_char    # Loop if index < size

end_science_check:
    jmp update_type4         # Go to update type 4

not_science:
    movw $4, type            # Set type to 4

update_type4:
    movw $4, type            # Set type to 4

end:
    mov $60, %rax            # exit system call
    xor %rdi, %rdi           # status 0
    syscall

.section .rodata
type_label:
    .asciz "type="
newline:
    .byte 10                 # ASCII code for newline ('\n')

.section .bss
    .lcomm type_buf, 13      # buffer to hold string representation of type
    .lcomm type, 2           # reserve 2 bytes for type in the BSS section

.section .data
size:
    .quad 0                  # Define the size variable
data:
    .quad 0                  # Define the data variable
